#!/usr/bin/env python3

import os
import sys
import traceback
import glob
import logging
import configparser
from collections import defaultdict

import lilaclib
from lilaclib import *

REPODIR = os.path.expanduser('~/archgitrepo')
DESTDIR = '~/repo'
MYNAME = 'lilac'
MYADDRESS = '<lilac@build.archlinuxcn.org>'
MYMASTER = 'lilydjwg <lilydjwg@gmail.com>'

from nicelogger import enable_pretty_logging
enable_pretty_logging('DEBUG', color=True)

logger = logging.getLogger(__name__)
MYEMAIL = MYNAME + ' ' + MYADDRESS
nvchecker_full = os.path.expanduser(os.path.join(REPODIR, 'nvchecker.ini'))
mydir = os.path.expanduser('~/.lilac')
try:
  os.mkdir(mydir)
except FileExistsError:
  pass
store = os.path.join(mydir, 'store')
oldver_file = os.path.join(mydir, 'oldver')
open(oldver_file, 'a').close()
newver_file = os.path.join(mydir, 'newver')
nvchecker_file = os.path.join(mydir, 'nvchecker.ini')
building_packages = set()
nvdata = {}

build_logger = logging.getLogger('build')
def setup_build_logger():
  handler = logging.FileHandler(os.path.join(mydir, 'build.log'))
  handler.setFormatter(logging.Formatter('[%(asctime)s] %(message)s', '%Y-%m-%d %H:%M:%S'))
  build_logger.addHandler(handler)

def build_package(package):
  logger.info('building %s', package)
  path = os.path.join(REPODIR, package)
  with at_dir(path):
    try:
      n = nvdata.get(package, (None, None))
      lilac_build(
        REPODIR,
        oldver = n[0], newver = n[1],
      )
      sign_and_copy()
      lilaclib.build_output = None
      build_logger.info('%s successful', package)
      return True
    except TryNextRound:
      raise
    except Exception as e:
      tb = traceback.format_exc()
      logger.exception('packaging error')
      send_error_report(package, e, tb)
      build_logger.error('%s failed', package)

def send_error_report(name, exception, tb):
  try:
    who = find_maintainer(MYADDRESS)
    more = ''
  except:
    who = MYMASTER
    more = traceback.format_exc()

  if isinstance(exception, CalledProcessError):
    subject = '[lilac] 在编译软件包 %s 时发生错误' % name
    msg = '命令执行失败！\n\n命令 %r 返回了错误号 %d。' \
        '命令的输出如下：\n\n%s' % (
      exception.cmd, exception.returncode, exception.output)
    msg += '\n调用栈如下：\n\n' + tb
  else:
    subject = '[lilac] 在编译软件包 %s 时发生未知错误' % name
    msg = '发生未知错误！调用栈如下：\n\n' + tb
  if more:
    msg += '\n获取维护者信息也失败了！调用栈如下：\n\n' + more
  if lilaclib.build_output:
    msg += '\n编译命令输出如下：\n\n' + lilaclib.build_output

  sendmail(who, MYEMAIL, subject, msg)

def sign_and_copy():
  pkgs = [x for x in os.listdir() if x.endswith('.pkg.tar.xz')]
  for pkg in pkgs:
    run_cmd(['gpg', '--detach-sign', '--', pkg])
  run_cmd(["zsh", "-c",
           'cp *.(pkg.tar.xz{,.sig}|src.tar.gz) ' + DESTDIR])

def packages_need_update(U):
  full = configparser.ConfigParser(dict_type=dict, allow_no_value=True)
  try:
    full.read([nvchecker_full])
  except:
    tb = traceback.format_exc()
    try:
      who = find_maintainer(MYADDRESS, file='nvchecker.ini')
      more = ''
    except:
      who = MYMASTER
      more = traceback.format_exc()

    subject = '[lilac] nvchecker 配置文件错误'
    msg = '调用栈如下：\n\n' + tb
    if more:
      msg += '\n获取维护者信息也失败了！调用栈如下：\n\n' + more
    sendmail(who, MYEMAIL, subject, msg)
    raise

  all_known = set(full.sections())
  unknown = U - all_known
  if unknown:
    logger.warn('unknown packages: %r', unknown)

  newconfig = {k: full[k] for k in U & all_known}
  newconfig['__config__'] = {
    'oldver': oldver_file,
    'newver': newver_file,
  }
  new = configparser.ConfigParser(dict_type=dict, allow_no_value=True)
  new.read_dict(newconfig)
  with open(nvchecker_file, 'w') as f:
    new.write(f)
  output = run_cmd(['nvchecker', nvchecker_file])

  error = False
  errorlines = []
  for l in output.splitlines():
    if l.startswith('[E'):
      error = True
    elif l.startswith('['):
      error = False
    if error:
      errorlines.append(l)

  if unknown or errorlines:
    subject = '[lilac] nvchecker 配置需要更新'
    msg = ''
    if unknown:
      msg += '以下软件包没有相应的更新配置信息：\n\n' + ''.join(
        x + '\n' for x in sorted(unknown)) + '\n'
    if errorlines:
      msg += '以下软件包在更新检查时出错了：\n\n' + '\n'.join(
        errorlines) + '\n'
    sendmail(MYMASTER, MYEMAIL, subject, msg)

  for x in run_cmd(['nvcmp', nvchecker_file]).splitlines():
    pkg, oldver, _, newver = x.split()
    nvdata[pkg] = oldver, newver

  updated = set(nvdata.keys())
  return updated, unknown

def all_packages_I_manage():
  r = glob.glob('*/lilac.py')
  return {x.split('/', 1)[0] for x in r}

def start_build():
  failed = set()
  dep_map = defaultdict(set)

  while True:
    next_round = set()
    oldset = building_packages.copy()
    logger.info('building these packages: %r', building_packages)
    while True:
      try:
        pkg = building_packages.pop()
      except KeyError:
        break
      try:
        if not build_package(pkg):
          failed.add(pkg)
          if pkg in dep_map:
            # all pkgs depend on this fails and don't build them
            deps = dep_map[pkg]
            failed.update(deps)
            building_packages.difference_update(deps)
      except TryNextRound as e:
        oldset.update(e.deps)
        building_packages.update(e.deps)
        for p in e.deps:
          dep_map[p].add(pkg)
        next_round.add(pkg)
        logger.debug('current dep map: %r, next_round: %r, oldset: %r',
                     dep_map, next_round, oldset)

    if not next_round:
      break
    if oldset == next_round:
      raise Exception('cyclic dependency? %r' % next_round)
    building_packages.update(next_round - failed)
    logger.debug('new round, to be built: %r, failed: %r',
                 building_packages, failed)

  return failed

def main():
  with PickledData(store, default={}) as D:
    try:
      git_reset_hard()
      git_pull()

      U = all_packages_I_manage()
      last_commit = D.get('last_commit', EMPTY_COMMIT)
      revisions = last_commit + '..HEAD'
      changed = get_changed_packages(revisions, U)
      failed_prev = D.get('failed', set())

      updated, unknown = packages_need_update(U)
      need_update = updated
      need_rebuild_failed = failed_prev & changed
      need_rebuild_pkgrel = {x for x in changed
                             if pkgrel_changed(revisions, x)} - unknown
      all_building = need_update | need_rebuild_failed | need_rebuild_pkgrel

      logger.info('these updated (pkgrel) packages should be rebuilt: %r',
                  need_rebuild_pkgrel or None)
      logger.info('these previously-failed packages should be rebuilt: %r',
                  need_rebuild_failed or None)
      logger.info('these packages are updated as detected by nvchecker: %r',
                  need_update or None)

      building_packages.update(all_building)
      failed = start_build()

      D['last_commit'] = git_last_commit()
      D['failed'] = failed | (failed_prev - all_building)
      update_succeeded = all_building - failed
      if update_succeeded:
        run_cmd(['nvtake', nvchecker_file] + list(update_succeeded & need_update))
      git_reset_hard()
      git_push()
    except Exception as e:
      tb = traceback.format_exc()
      logger.exception('unexpected error')
      subject = '[lilac] 运行时错误'
      msg = '调用栈如下：\n\n' + tb
      sendmail(MYMASTER, MYEMAIL, subject, msg)

if __name__ == '__main__':
  setup_build_logger()
  os.chdir(REPODIR)

  if len(sys.argv) == 1:
    main()
  else:
    building_packages.update(sys.argv[1:])
    start_build()
