#!/usr/bin/python3 -u

import os
import sys
import traceback
import glob
import logging
import configparser
from collections import defaultdict

import lilaclib
from lilaclib import *

REPODIR = os.path.expanduser('~/archgitrepo')
DESTDIR = '~/repo'
MYNAME = 'lilac'
MYADDRESS = '<lilac@build.archlinuxcn.org>'
MYMASTER = 'lilydjwg <lilydjwg@gmail.com>'
REPOMAIL = 'repo@archlinuxcn.org'

from nicelogger import enable_pretty_logging
enable_pretty_logging('DEBUG', color=True)

logger = logging.getLogger(__name__)
MYEMAIL = MYNAME + ' ' + MYADDRESS
nvchecker_full = os.path.expanduser(os.path.join(REPODIR, 'nvchecker.ini'))
mydir = os.path.expanduser('~/.lilac')
try:
  os.mkdir(mydir)
except FileExistsError:
  pass
store = os.path.join(mydir, 'store')
oldver_file = os.path.join(mydir, 'oldver')
open(oldver_file, 'a').close()
newver_file = os.path.join(mydir, 'newver')
nvchecker_file = os.path.join(mydir, 'nvchecker.ini')
building_packages = set()
nvdata = {}
nv_unchanged = {}

build_logger = logging.getLogger('build')
def setup_build_logger():
  handler = logging.FileHandler(os.path.join(mydir, 'build.log'))
  handler.setFormatter(logging.Formatter('[%(asctime)s] %(message)s', '%Y-%m-%d %H:%M:%S'))
  build_logger.addHandler(handler)

def build_package(package):
  logger.info('building %s', package)
  path = os.path.join(REPODIR, package)
  with at_dir(path):
    try:
      n = nvdata.get(package, (nv_unchanged[package],) * 2)
      lilac_build(
        REPODIR,
        oldver = n[0], newver = n[1],
      )
      sign_and_copy()
      lilaclib.build_output = None
      build_logger.info('%s successful', package)
      return True
    except TryNextRound:
      raise
    except Exception as e:
      tb = traceback.format_exc()
      logger.exception('packaging error')
      send_error_report(package, exc=(e, tb))
      build_logger.error('%s failed', package)

def find_maintainer_or_admin(package=None):
  if package is not None:
    path = os.path.join(REPODIR, package)
  else:
    path = '.'

  with at_dir(path):
    try:
      who = find_maintainer(MYADDRESS)
      more = ''
    except:
      who = MYMASTER
      more = traceback.format_exc()

  return who, more

def send_error_report(name, *, msg=None, exc=None, subject=None):
  if msg is None and exc is None:
    raise TypeError('send_error_report received inefficient args')

  who, tb_find = find_maintainer_or_admin()

  msgs = []
  if msg is not None:
    msgs.append(msg)

  if exc is not None:
    exception, tb = exc
    if isinstance(exception, CalledProcessError):
      subject = subject or '[lilac] 在编译软件包 %s 时发生错误'
      msgs.append('命令执行失败！\n\n命令 %r 返回了错误号 %d。' \
                  '命令的输出如下：\n\n%s' % (
                    exception.cmd, exception.returncode, exception.output))
      msgs.append('调用栈如下：\n\n' + tb)
    else:
      subject = subject or '[lilac] 在编译软件包 %s 时发生未知错误'
      msgs.append('发生未知错误！调用栈如下：\n\n' + tb)

  if '%s' in subject:
    subject = subject % name

  if tb_find:
    msgs.append('获取维护者信息也失败了！调用栈如下：\n\n' + tb_find)
  if lilaclib.build_output:
    msgs.append('编译命令输出如下：\n\n' + lilaclib.build_output)

  msg = '\n'.join(msgs)
  sendmail(who, MYEMAIL, subject, msg)

def sign_and_copy():
  pkgs = [x for x in os.listdir() if x.endswith('.pkg.tar.xz')]
  run_cmd(["zsh", "-c",
           'cp -l *.(pkg.tar.xz(|.sig)|src.tar.gz) ' + DESTDIR])

def packages_need_update(U):
  full = configparser.ConfigParser(dict_type=dict, allow_no_value=True)
  try:
    full.read([nvchecker_full])
  except:
    tb = traceback.format_exc()
    try:
      who = find_maintainer(MYADDRESS, file='nvchecker.ini')
      more = ''
    except:
      who = MYMASTER
      more = traceback.format_exc()

    subject = '[lilac] nvchecker 配置文件错误'
    msg = '调用栈如下：\n\n' + tb
    if more:
      msg += '\n获取维护者信息也失败了！调用栈如下：\n\n' + more
    sendmail(who, MYEMAIL, subject, msg)
    raise

  all_known = set(full.sections())
  unknown = U - all_known
  if unknown:
    logger.warn('unknown packages: %r', unknown)

  newconfig = {k: full[k] for k in U & all_known}
  newconfig['__config__'] = {
    'oldver': oldver_file,
    'newver': newver_file,
  }
  new = configparser.ConfigParser(dict_type=dict, allow_no_value=True)
  new.read_dict(newconfig)
  with open(nvchecker_file, 'w') as f:
    new.write(f)
  output = run_cmd(['nvchecker', nvchecker_file])

  error = False
  errorlines = []
  for l in output.splitlines():
    if l.startswith('[E'):
      error = True
    elif l.startswith('['):
      error = False
    if error:
      errorlines.append(l)

  if unknown or errorlines:
    subject = '[lilac] nvchecker 问题'
    msg = ''
    if unknown:
      msg += '以下软件包没有相应的更新配置信息：\n\n' + ''.join(
        x + '\n' for x in sorted(unknown)) + '\n'
    if errorlines:
      msg += '以下软件包在更新检查时出错了：\n\n' + '\n'.join(
        errorlines) + '\n'
    sendmail(REPOMAIL, MYEMAIL, subject, msg)

  for x in run_cmd(['nvcmp', nvchecker_file]).splitlines():
    pkg, oldver, _, newver = x.split()
    if oldver == 'None':
      oldver = None
    nvdata[pkg] = oldver, newver
  with open(newver_file) as f:
    nv_unchanged.update(x.split(None, 1) for x in f)

  updated = set(nvdata.keys())
  return updated, unknown

def all_packages_I_manage():
  r = glob.glob('*/lilac.py')
  return {x.split('/', 1)[0] for x in r}

def start_build():
  failed = set()
  built = set()
  dep_map = defaultdict(set)

  def record_failed(pkg):
    failed.add(pkg)
    if pkg in dep_map:
      # all pkgs depend on this fails and don't build them
      deps = dep_map[pkg]
      failed.update(deps)
      building_packages.difference_update(deps)

  while True:
    next_round = set()
    oldset = building_packages.copy()
    logger.info('building these packages: %r', building_packages)
    while True:
      try:
        pkg = building_packages.pop()
      except KeyError:
        break
      try:
        if build_package(pkg):
          built.add(pkg)
        else:
          record_failed(pkg)
      except TryNextRound as e:
        if not (e.deps - built):
          # all deps built successfully, but packages still missing --- arch
          # not met
          send_error_report(pkg, subject='%s 出现依赖问题',
                            msg = '''\
在成功地编译打包 {built} 之后，{pkg} 依旧依赖 {deps}。

这可能是 {deps} 中的某些包不支持需要的架构 {arch} 所导致的，请检查。'''.format(
  built = built, deps = e.deps, arch = e.arch, pkg = pkg,
))
          record_failed(pkg)
        else:
          oldset.update(e.deps)
          building_packages.update(e.deps)
          for p in e.deps:
            dep_map[p].add(pkg)
          next_round.add(pkg)
      logger.debug('current dep map: %r, next_round: %r, oldset: %r',
                    dep_map, next_round, oldset)

    if not next_round:
      break
    if oldset == next_round:
      raise Exception('cyclic dependency? %r' % next_round)
    building_packages.update(next_round - failed)
    logger.debug('new round, to be built: %r, failed: %r',
                 building_packages, failed)

  return failed

def main():
  with PickledData(store, default={}) as D:
    try:
      git_reset_hard()
      git_pull()

      U = all_packages_I_manage()
      last_commit = D.get('last_commit', EMPTY_COMMIT)
      revisions = last_commit + '..HEAD'
      changed = get_changed_packages(revisions, U)
      failed_info = D.get('failed', {})
      updated, unknown = packages_need_update(U)

      failed_prev = set(failed_info.keys())
      failed_updated = {k for k, v in failed_info.items()
                        if k in nvdata and nvdata[k][1] != v}
      # build updated; if last build failed but it gets updated once more,
      # build it again
      need_update = updated | failed_updated
      # no update from upstream, but build instructions have changed; rebuild
      # failed ones
      need_rebuild_failed = failed_prev & changed
      # if pkgrel is updated, build a new release
      need_rebuild_pkgrel = {x for x in changed
                             if pkgrel_changed(revisions, x)} - unknown
      all_building = need_update | need_rebuild_failed | need_rebuild_pkgrel

      logger.info('these updated (pkgrel) packages should be rebuilt: %r',
                  need_rebuild_pkgrel or None)
      logger.info('these previously-failed packages should be rebuilt: %r',
                  need_rebuild_failed or None)
      logger.info('these packages are updated as detected by nvchecker: %r',
                  need_update or None)

      building_packages.update(all_building)
      failed = start_build()

      D['last_commit'] = git_last_commit()
      update_succeeded = all_building - failed
      failed_info.update({k: nvdata[k][1] for k in failed if k in nvdata})
      for x in update_succeeded:
        if x in failed_info:
          del failed_info[x]
      D['failed'] = failed_info
      if update_succeeded:
        run_cmd(['nvtake', nvchecker_file] + list(need_update))
      git_reset_hard()
      git_push()
    except Exception as e:
      tb = traceback.format_exc()
      logger.exception('unexpected error')
      subject = '[lilac] 运行时错误'
      msg = '调用栈如下：\n\n' + tb
      sendmail(MYMASTER, MYEMAIL, subject, msg)

if __name__ == '__main__':
  setup_build_logger()
  os.chdir(REPODIR)

  if len(sys.argv) == 1:
    main()
  else:
    building_packages.update(sys.argv[1:])
    start_build()
